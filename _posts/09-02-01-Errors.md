--- 
title: خطا
isChild: true 
anchor: errors
---

## خطا {#errors_title}

در زبان‌های برنامه‌نویسی که "خطایابی سنگین" دارند، هر زمان خطایی رخ دهد یک استثنا به وجود می‌آید. البته این روش ماندگاری جهت انجام کارها است اما PHP یک زبان برنامه‌نویسی با "خطایابی سبک" است. اگرچه دارای عملیات خطایابی است و قسمت بزرگی از هسته (Zend Engine) برای کار با شی‌های مختلف از آن بهره می‌برد، اما در بسیاری عملیات دیگر، PHP به ادامه‌ی پردازش برنامه ادامه می‌دهد مگر اینکه یک خطای مهلک رخ داده باشد.

برای نمونه:

{% highlight php %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

این خطا از نوع اطلاع‌رسانی است و PHP با آن کاری ندارد. این امر ممکن است برای افرادی که با مکانیزم خطایابی سایر زبان‌های برنامه‌نویسی آشنا هستند، گیج‌کننده باشد. برای نمونه، ارجاع به یک متغیر تعریف‌نشده در پایتون منجر به ایجاد یک استثنا می‌شود:

{% highlight python %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

تنها تفاوت این است که در پایتون کوچکترین خطا منجر به ایجاد یک استثنا می‌شود که اینکار به توسعه‌دهندگان اطمینان خاطر می‌دهد تمام حالت‌های نامطلوب در یک برنامه قابل رسیدگی هستند، اما PHP در برخورد با چنین خطاهایی به کار خود ادامه می‌دهد مگر اینکه آن خطا مهلک باشد که در این نقطه اجرای برنامه متوقف و خطا گزارش می‌شود.

### شدت خطا

سطح‌های مختلفی از شدت خطا در PHP وجود دارد که سه سطح خطا، اعلان و هشدار بسیار مرسوم هستند که با استفاده از `E_NOTICE`، `E_ERROR` و `E_WARNING` تعریف شده‌اند. خطاها، در زمان اجرا رخ می‌دهند و مهلک هستند و معمولا منشا در کد اصلی برنامه دارند که منجر به توقف اجرای آن می‌شوند. اعلان‌ها، پیام‌هایی هستند که توجه نکردن به آن‌ها ممکن است منجر به توقف برنامه بشود یا نشود و اجرای برنامه را متوقف نمی‌کنند. هشدارها خطاهایی غیر مهلک هستند که منجر به توقف برنامه نمی‌شوند.

نوع دیگری از این پیام‌ها که در زمان کامپایل رخ می‌دهند، پیام‌های `E_STRICT` است. این پیام‌ها به شما پیشنهادهایی درباره تغییر کد فعلی می‌دهند تا نرم‌افزار شما با نسخه‌های بعدی PHP سازگاری بیشتری داشته باشد.

### تغییر روش گزارش‌دهی خطا در PHP

گزارش‌دهی خطا با استفاده از تنظیمات سراسری PHP یا فراخوانی برخی توابع قابل تغییر است. با استفاده از تابع `()error_reporting` می‌توانید سطح خطایی را که در زمان اجرای اسکریپت رخ می‌دهد با استفاده از متغیرهای ثابت، تنظیم کنید. بدین معنی که اگر می‌خواهید تنها خطاها و هشدارها را مشاهده کنید - و نه اعلان‌ها - بدین شکل آن را تنظیم کنید:

{% highlight php %}
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

همچنین می‌توانید نحوه‌ی نمایش خطا روی نمایشگر (مناسب زمان توسعه)، عدم نمایش آن و ثبت شدن (مناسب زمان اجرا) آن را کنترل کنید. برای اطلاعات بیشتر در این مورد بخش [گزارش‌دهی خطا][errorreport] را مشاهده کنید.

### جلوگیری از نمایش خطا

با استفاده از عملگر کنترل خطا `@` می‌توانید از به وجود آمدن برخی خطاها جلوگیری کنید. با قرار دادن این عملگر در ابتدای عبارت اگر خطایی از آن عبارت به وجود آید، گزارش داده نمی‌شود.

{% highlight php %}
echo @$foo['bar'];
{% endhighlight %}

خروجی این دستور در صورت وجود `$foo['bar']` خواهد بود، اما اگر متغیر `foo$` یا کلید `'bar'` وجود نداشته باشند خروجی null باز می‌گرداند یا چیزی چاپ نمی‌شود. بدون استفاده از عملگر کنترل خطا، این عبارت می‌توانست یک خطای `PHP Notice:  Undefined variable: foo` یا `PHP Notice:  Undefined index: bar` به وجود آورد.

ممکن است ایده‌ی خوبی به نظر بیاید اما ممکن است نتایج نامطلوبی در پی داشته باشد. عبارت‌هایی که شامل عملگر `@` هستند سرعت اجرای کمتری نسبت به سایر عبارت‌ها دارند. بهینه‌سازی پیش از موعد (قبل از اجرای نهایی برنامه) از مباحث ریشه‌ای در مناظره‌های برنامه‌نویسی به حساب می‌آید، اما اگر کارایی و قابلیت اجرای بالا برای برنامه‌ی شما مهم است، درک صحیحی از کارایی پایین برنامه با استفاده از عملگر کنترل خطا مورد نیاز شما است.

از طرف دیگر، عملگر کنترل خطا به صورت **کامل** خطا را محو می‌سازد. خطا نه تنها نمایش داده نمی‌شود بلکه جایی نیز ثبت نمی‌گردد. همچنین در محیط‌های فعال PHP (مانند سرورها)، راهی برای غیرفعال کردن این عملگر وجود ندارد. ممکن است در مرحله‌ی اول خطایی که می‌بینید بدون ضرر باشد، اما همان نیز نمایش داده نمی‌شود و جایی ثبت نمی‌گردد.

اگر راهی برای غیرفعال کردن این عملگر وجود دارد باید از آن بهره گیرید. برای نمونه، کد بالا می‌تواند بدین شکل نوشته شود:

{% highlight php %}
echo isset($foo['bar']) ? $foo['bar'] : '';
{% endhighlight %}

یکی از نمونه‌هایی که این عملگر در آن کاربرد دارد تابع `()fopen` است که نمی‌تواند فایل مورد نظر را بارگیری کند. قبل از بارگیری فایل می‌توانید وجود یا عدم وجود آن را بررسی کنید، اما اگر فایل بلافاصله پس از بررسی شما پاک شود آنگاه `()fopen` مقدار false و _یک_ خطا باز می‌گرداند. البته این مشکلی است که PHP باید حل کند اما جزو مواردی به حساب می‌آید که عملگر کنترل خطا می‌تواند کاربرد داشته باشد.

پیشتر اشاره کردیم که در محیط‌های فعال PHP امکان غیرفعال‌سازی این عملگر وجود ندارد. اگرچه، [xDebug] یک تنظیم `xdebug.stream` در سطح ini دارد که این عملگر را غیرفعال می‌سازد. می‌توانید با استفاده از فایل `php.ini` آن را تنظیم کنید.

    xdebug.scream = On

همچنین می‌توانید در زمان اجرا و با استفاده از تابع `ini_set` آن را تنظیم کنید

{% highlight php %}
ini_set('xdebug.scream', '1')
{% endhighlight %}

افزونه‌ی "[Scream]" برای PHP عملکرد مشابهی مانند xDebug دارد با این تفاوت که نام آن `scream.enabled` است.

این برای زمانی مفید است که احساس می‌کنید جلوگیری از نمایش خطا، اطلاعات مفیدی را از شما پنهان می‌سازد. از این افزونه با احتیاط و به عنوان یک ابزار کمکی جهت خطایابی استفاه کنید. کدهای فراوانی از کتابخانه‌ی PHP وجود دارند که با خاموش بودن کامل این عملگر کار نخواهند کرد.


* [عملگرهای کنترل خطا](http://php.net/manual/en/language.operators.errorcontrol.php)
* [SitePoint](http://www.sitepoint.com/)
* [xDebug]
* [Scream]

[xDebug]: http://xdebug.org/docs/basic
[Scream]: http://www.php.net/manual/en/book.scream.php

### ErrorException

برای اینکه PHP به یک زبان برنامه‌نویسی با قابلیت "خطایابی سنگین" تبدیل شود تنها اضافه شدن چند خط کد کافی است. می‌توانید با استفاده از کلاس `ErrorException` که خود از کلاس `Exception` مشتق شده است، "خطا"های خود را به عنوان "استثنا" در نظر بگیرید.

این تکنیک متدوالی است که توسط اکثر چارچوب‌های نرم‌افزاری مدرن مانند Symfony یا Laravel پیاده‌سازی شده است. Laravel به صورت پیش‌فرض تمام خطاها را به صورت استثا با استفاده از بسته‌ی نرم‌افزاری [!Whoops] نمایش می‌دهد در صورتی که گزینه‌ی `app.debug` فعال باشد و در صورت غیرفعال بودن آن‌ها را پنهان می‌سازد.

با تبدیل خطاها به استثناها در زمان تولید نرم‌افزار، می‌توانید آن‌ها را بهتر از حالت اولیه‌شان مدیریت کنید و اگر در این زمان به یک استثنا برخورد کردید می‌توانید به راحتی آن را با استفاده از دستور catch بررسی کنید. با بررسی هر استثنا در این زمینه، برنامه‌ی شما به مرور زمان پایدارتر خواهد شد.

اطلاعات بیشتر در مورد `ErrorException` و نحوه‌ی بررسی خطا در [کلاس ErrorException][errorexception] قابل دسترس است.

* [Error Control Operators](http://php.net/manual/en/language.operators.errorcontrol.php)
* [Predefined Constants for Error Handling](http://www.php.net/manual/en/errorfunc.constants.php)
* [error_reporting](http://www.php.net/manual/en/function.error-reporting.php)
* [Reporting][errorreport]

[errorexception]: http://php.net/manual/en/class.errorexception.php
[errorreport]: /#error_reporting
[Whoops!]: http://filp.github.io/whoops/
