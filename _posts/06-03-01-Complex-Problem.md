---
title: مشکل پیچیده
isChild: true
anchor: complex_problem
---

## مشکل پیچیده {#complex_problem_title}

اگر تا به حال درباره‌ی Dependency Injection مطلبی خوانده باشید با عبارت‌هایی مانند *"Inversion of Control"* یا *"Dependency Inversion Principle"* مواجه شده‌اید. این‌ها مشکل‌های پیچیده‌ای هستند که Dependency Injection آن‌ها را رفع می‌کند.

### Inversion of Control

این عبارت همانطور که از نامش پیداست با جدا نگاه‌داشتن کنترل از تمام شی‌ها، "کنترل را وارونه" می‌سازد. در تعریف Dependency Injection به این معناست که وابستگی‌های موجود را با نمونه‌سازی در قسمت‌های دیگر، ضعیف سازیم.

برای سال‌ها، فریم‌ورک‌های PHP این تکنیک را به کار گرفته‌اند، اگرچه پرسش این است که کدام قسمت کنترل را وارونه می‌سازید و به کجا؟ برای نمونه، فریم‌ورک‌های MVC معمولا یک شی پایه یا کنترل‌کننده‌ی پایه را به وجود می‌آورند که سایر کنترل‌کننده‌ها برای دسترسی به وابستگی‌های آن از این شی پایه ارث‌بری می‌کنند. این **همان** مفهوم وارونگی کنترل است، اگرچه به جای تضعیف وابستگی‌ها، این روش آن‌ها را منتقل می‌کند.

Dependency Injection به ما کمک می‌کند که این مشکل را با تعریف وابستگی‌هایی که تنها به آن‌ها نیاز داریم، رفع کنیم.

### Dependency Inversion Principle

این عبارت همان حرف "D" در مجموعه S.O.L.I.D در رابطه با طراحی شی‌گرا است که بیان می‌کند هر جز از سیستم باید *"به انتزاع وابسته باشد، نه به پیاده‌سازی خاص"*. ساده‌تر بگوییم، وابستگی‌ها باید Interface یا Abstract Class باشند تا یک پیاده‌سازی خاص. نمونه بالا را می‌توان به سادگی به این مفهوم تبدیل کرد.

{% highlight php %}
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct(AdapterInterface $adapter)
    {
        $this->adapter = $adapter;
    }
}

interface AdapterInterface {}

class MysqlAdapter implements AdapterInterface {}
{% endhighlight %}

مزایای بسیاری در این کلاس `Database` وجود دارد که به یک Interface وابسته است تا به یک پیاده‌سازی خاص.

تصور کنید در تیمی کار می‌کنید که پیاده‌سازی adapter به عهده‌ی عضوی دیگر است. در اولین نمونه، باید منتظر بمانیم تا همکار ما کار روی adapter را تمام کرده سپس ما آزمایش مورد نظر را انجام دهیم. حالا که وابستگی به یک Interface وجود دارد با خیال راحت می‌توانیم به کار خود ادامه دهیم و اطمینان داشته باشیم که ناتمام بودن adapter روی کار ما تاثیر منفی نمی‌گذارد.

مزیت بزرگ دیگری که در این روش وجود دارد این است که کد مقیاس‌پذیری بیشتری دارد. اگر سال بعد تصمیم بگیریم که از یک پایگاه‌داده‌ی دیگر استفاده کنیم تنها کافی است برای آن پایگاه‌داده بر اساس Interface فعلی یک adapter پیاده‌سازی کنیم که از تمام ویژگی‌های فعلی پشتیبانی می‌کند.
